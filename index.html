<!DOCTYPE html><html><head><base href="/testing-practices/"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Testing Practices</title><link rel="stylesheet" href="dist/reset.css" type="text/css"><link rel="stylesheet" href="dist/reveal.css" type="text/css"><link rel="stylesheet" href="dist/theme/black.css" type="text/css"><link rel="stylesheet" href="plugin/highlight/monokai.css" type="text/css"></head><body><div class="reveal"><div class="slides"><section><h1>Testing Practices</h1><p>by Nico Vogel</p></section><section><p>Quick disclaimer: This is only an introduction</p><p>Also, this presentation contains multiple view points
And therefore not everything can be applied at once.</p><p>That said, there are some musts in this presentation</p></section><section><h1>Agenda</h1><ul><li>Unit Testing</li><li>E2E Testing</li><li>TDD (test driven development)</li></ul><blockquote>frontend oriented, but can be applied in backend</blockquote><aside class="notes">This presentation is frontend focused, but the techniques can be applied in backend as well.
From a topic perspective, we will cover unit testing, e2e testing and</aside></section><section><h1>Unit testing</h1><aside class="notes">Unit testing is a skill that takes practice, but is sadly
hardly addressed in university.
</aside></section><section><h2>What is unit testing?</h2><p>A practice to test parts of your code quickly.</p><aside class="notes">Even tough this statement might seem straight forward at first
glance, there are multiple nuances to this skill and I will
outline some of them.
</aside></section><section><section><h2>What should you actually test?</h2><ul><li>class's?</li><li>functions?</li><li>attributes?</li><li>services?</li><li>components?</li><li>...?</li></ul><aside class="notes">The fist thing to understand is what are we actually testing in unit tests
What do you think, which of these do we test?
As always, the answer is: (next slide)
</aside></section><section><p>What do you actually test?</p><h3>Behavior</h3><aside class="notes">This is a clear must do and it should not be open to debate.
</aside></section><section><img class="r-stretch" src="/img/confused-meme.jpg" style="background: white"></section><section><h3>How to test behavior?</h3><ul><li>ensure that the system is in the correct state</li><li>execute some action</li><li>expect that the system changed according to the behavior</li></ul><p>Most of the time its calling a function or an objects method.
</p></section><section><h3>Common mistakes to avoid</h3><ul><li>testing every function of a class</li><li>testing every attribute of a class</li><li>making assertions that some internal stuff happens in a class</li></ul><aside class="notes">Lets look at an example.
</aside></section><section><p>Imagine you work on a feature and your class gets bigger and bigger.
At some point you decide this is no longer understandable and you split
the class into multiple classes with one class (Main) that handles the others.</p><p><b>Test do not change for refactor</b></p><blockquote>As the other classes are just implementation details
they should not be mocked.</blockquote><aside class="notes">You should not even write tests for such implementations.
In case that you want or need to test them, you need to mark them
in some way that they are deleted if needed, as they only reflect a
partial behavior.
</aside></section><section><h3>Don't test implementation details</h3><p>The sub classes don't need tests.
If you want to test them anyways, then mark the tests as
"throw away" or something similar.</p><aside class="notes">Whenever implementation details a^^re tested, then you need to
expect that you need to remove the tests when the code is refactored.
</aside></section><section><h3>What are the benefits of this?</h3><p>Tests only break if you change the behavior of the system
and not if you refactor code</p></section></section><section><section><h2>How should you structure your tests?</h2><ul><li>A test</li><li>A test file</li></ul></section><section><h3>Test structure</h3><ul><li>Given (Arrange)</li><li>When (Act)</li><li>Then (Assert)</li></ul><blockquote>A behavior test tends to only include one assertions (rarely more).
</blockquote></section><style>ol.level {
  counter-reset: item -1;
  list-style-type: none;
}

ol.level li:before {
  content: 'L' counter(item, decimal) ': ';
  counter-increment: item;
}
</style><section><h3>Test file structure</h3><ol class="level"><li>Getting familiar</li><li>Depend on class (DI)</li><li>Depend on class internal</li><li>Test setup dependency</li><li>Multi level describes</li><li>Async tests</li><li>Automate test creation</li></ol></section><section data-auto-animate data-auto-animate-id="L0"><h3 class="level" data-id="code-title">L0: Getting familiar</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="">class Component {
  greet() { return "hello world"; }
}

</code></pre></section><section data-auto-animate data-auto-animate-id="L0"><h3 class="level" data-id="code-title">L0: Getting familiar</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="5-9">class Component {
  greet() { return "hello world"; }
}

describe("L0", () => {
  let sut: Component;

  beforeEach(() => sut = new Component());
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L0"><h3 class="level" data-id="code-title">L0: Getting familiar</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="10-13">class Component {
  greet() { return "hello world"; }
}

describe("L0", () => {
  let sut: Component;

  beforeEach(() => sut = new Component());

  it("should return hello world", () => {
    const result = sut.greet();
    expect(result).to.equal("hello world");
  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L0"><h3 class="level" data-id="code-title">L0: Getting familiar</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="10-18">class Component {
  greet() { return "hello world"; }
}

describe("L0", () => {
  let sut: Component;

  beforeEach(() => sut = new Component());

  it("should return hello world", () => {
    // Given

    // When
    const result = sut.greet();

    // Then
    expect(result).to.equal("hello world");
  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L1"><h3 class="level" data-id="code-title">L1: Depend on class (DI)</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="|7,16">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

</code></pre></section><section data-auto-animate data-auto-animate-id="L1"><h3 class="level" data-id="code-title">L1: Depend on class (DI)</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="21-31|23,26,29">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

describe("L1", () => {
  let sut: Component;
  let service: StubbedInstance&lt;Service>;

  beforeEach(() => {
    service = stubInterface&lt;Service>();
    sut = new Component(service);
  });
  afterEach(() => sinon.restore());
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L1"><h3 class="level" data-id="code-title">L1: Depend on class (DI)</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="31-40">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

describe("L1", () => {
  let sut: Component;
  let service: StubbedInstance&lt;Service>;

  beforeEach(() => {
    service = stubInterface&lt;Service>();
    sut = new Component(service);
  });
  afterEach(() => sinon.restore());

  it("should process empty items", () => {
    // Given
    service.getItems.return([]);

    // When
    const result = sut.getGroupedItems();

    // Then
    expect(result).to.equal(new Map());
  })
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L2"><h3 class="level" data-id="code-title">L2: Depend on class internal</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="|6-7">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  private service = new Service();
  // constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

</code></pre></section><section data-auto-animate data-auto-animate-id="L2"><h3 class="level" data-id="code-title">L2: Depend on class internal</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="22-35|22,30-31">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  private service = new Service();
  // constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

import * as ServiceModule from './service';

describe("L2", () => {
  let sut: Component;
  let service: StubbedInstance&lt;Service>;

  beforeEach(() => {
    service = stubInterface&lt;Service>();
    // Override what the constructor of Service returns
    sinon.stub(ServiceModule, "Service").returns(service);
    sut = new Component(service);
  });
  afterEach(() => sinon.restore());
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L2"><h3 class="level" data-id="code-title">L2: Depend on class internal</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="36-45">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  private service = new Service();
  // constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

import * as ServiceModule from './service';

describe("L2", () => {
  let sut: Component;
  let service: Service;

  beforeEach(() => {
    service = stubInterface&lt;Service>();
    // Override what the constructor of Service returns
    sinon.stub(ServiceModule, "Service").returns(service);
    sut = new Component(service);
  });
  afterEach(() => sinon.restore());

  it("should process empty items", () => {
    // Given
    service.getItems.return([]);

    // When
    const result = sut.getGroupedItems();

    // Then
    expect(result).to.equal(new Map());
  })
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L2"><h3 class="level" data-id="code-title">L2: Depend on class internal</h3><p>Try to avoid this style as it makes tests needlessly complex</p><p>Use Dependency Injection instead to keep tests clean</p></section><section data-auto-animate data-auto-animate-id="L3"><h3 class="level" data-id="code-title">L3: Test setup dependency</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="|8,12">class Component {}
  public readonly id: number;

  constructor(url: string) {
    const urlWrapper = new URL(url);
    const idParam = urlWrapper.searchParams.get("id");
    if (!idParam) {
      throw new Error('The id parameter is required');
    }
    const parsedId = +idParam;
    if (Object.is(parsedId, NaN)) {
      throw new Error('The id parameter is not a number');
    }
    this.id = parsedId;
  }
}

</code></pre></section><section data-auto-animate data-auto-animate-id="L3"><h3 class="level" data-id="code-title">L3: Test setup dependency</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="18-23">class Component {}
  public readonly id: number;

  constructor(url: string) {
    const urlWrapper = new URL(url);
    const idParam = urlWrapper.searchParams.get("id");
    if (!idParam) {
      throw new Error('The id parameter is required');
    }
    const parsedId = +idParam;
    if (Object.is(parsedId, NaN)) {
      throw new Error('The id parameter is not a number');
    }
    this.id = parsedId;
  }
}

describe("L3", () => {
  let sut: Component;
  const initTest = (url) => {
    sut = new Component(url);
  }
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L3"><h3 class="level" data-id="code-title">L3: Test setup dependency</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="24-33|20-22,26">class Component {}
  public readonly id: number;

  constructor(url: string) {
    const urlWrapper = new URL(url);
    const idParam = urlWrapper.searchParams.get("id");
    if (!idParam) {
      throw new Error('The id parameter is required');
    }
    const parsedId = +idParam;
    if (Object.is(parsedId, NaN)) {
      throw new Error('The id parameter is not a number');
    }
    this.id = parsedId;
  }
}

describe("L3", () => {
  let sut: Component;
  const initTest = (url) => {
    sut = new Component(url);
  }

  it("should parse id successfully", () => {
    // Given
    initTest("http://test.com?id=1");

    // When
    const result = sut.id;

    // Then
    expect(result).to.equal(1);
  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L3"><h3 class="level" data-id="code-title">L3: Test setup dependency</h3><p>Usually needed when you want to test something within the constructor
or for L6</p></section></section><section><h2>Higher level test structures</h2><p>There are two options I know of:</p><ul><li>Contract tests</li><li>Sociable tests</li></ul><aside class="notes">Or you could also call it mindsets.
Just creating tests is fine, but its still possible that in the end
your tests succeed, but in production errors come up.
Following one of these higher level test structures can further
harden your testing.

You don't need to use any of these approaches and they can even be
considered "ugly" by some people
</aside></section><section><section><h2>Contract tests</h2><img class="r-stretch" src="/img/cdc-testing.png" style="background: white"><aside class="notes">Some might know this from the backend to test micro services.

But we often forget that whenever we mock something, then
this also applies to our tests.

At least the left part is usually considered when creating tests

-> img source: https://microsoft.github.io/code-with-engineering-playbook/automated-testing/cdc-testing/
</aside></section><section><h3>Example 1</h3><pre><code class="language-plantuml r-stretch">@startuml
Alice -> Bob: test
Bob --> Alice: Authentication Response
Alice -> Bob: Another authentication Request
Bob --> Alice: Another authentication Response
@enduml
</code></pre></section><section><h3>How to apply contracts testing?</h3><p>When

</p></section><section><h3></h3></section></section><section><section><h1>E2E testing</h1><p>End 2 End testing</p></section><section><h1>What is E2E testing?</h1></section><section><h1>How is it different from unit testing?</h1></section></section><section><section><h1>TDD</h1><p>Test Driven Development</p></section><section><h1>What is TDD?</h1></section></section></div></div><script src="dist/reveal.js"></script><script src="plugin/notes/notes.js"></script><script src="plugin/markdown/markdown.js"></script><script src="plugin/highlight/highlight.js"></script><script>Reveal.initialize( {
  hash: true,
  plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
} );</script></body></html>