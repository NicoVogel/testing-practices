<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Testing Practices</title><link rel="stylesheet" href="dist/reset.css" type="text/css"><link rel="stylesheet" href="dist/reveal.css" type="text/css"><link rel="stylesheet" href="dist/theme/black.css" type="text/css"><link rel="stylesheet" href="plugin/highlight/monokai.css" type="text/css"></head><body><div class="reveal"><div class="slides"><section><h1>Testing Practices</h1><p>by Nico Vogel</p></section><section><p>Quick disclaimer: This is only an introduction</p><p>Also, this presentation contains multiple view points
And therefore not everything can be applied at once.</p><p>That said, there are some musts in this presentation</p></section><section><h1>Agenda</h1><ul><li>Unit Testing</li><li>E2E Testing</li><li>TDD (test driven development)</li></ul><blockquote>frontend oriented, but can be applied in backend</blockquote><aside class="notes">This presentation is frontend focused, but the techniques can be applied in backend as well.
From a topic perspective, we will cover unit testing, e2e testing and</aside></section><section><h1>Unit testing</h1><aside class="notes">Unit testing is a skill that takes practice, but is sadly
hardly addressed in university.
</aside></section><section><h2>What is unit testing?</h2><p>A practice to test parts of your code quickly.</p><aside class="notes">Even tough this statement might seem straight forward at first
glance, there are multiple nuances to this skill and I will
outline some of them.
</aside></section><section><section><h2>What should you actually test?</h2><ul><li>class's?</li><li>functions?</li><li>attributes?</li><li>services?</li><li>components?</li><li>...?</li></ul><aside class="notes">The fist thing to understand is what are we actually testing in unit tests
What do you think, which of these do we test?
As always, the answer is: (next slide)
</aside></section><section><p>What do you actually test?</p><h3>Behavior</h3><aside class="notes">This is a clear must do and it should not be open to debate.
</aside></section><section><img class="r-stretch" src="/img/confused-meme.jpg" style="background: white"></section><section><h3>How to test behavior?</h3><ul><li>ensure that the system is in the correct state</li><li>execute some action</li><li>expect that the system changed according to the behavior</li></ul><p>Most of the time its calling a function or an objects method.
</p></section><section><h3>Common mistakes to avoid</h3><ul><li>testing every function of a class</li><li>testing every attribute of a class</li><li>making assertions that some internal stuff happens in a class</li></ul><aside class="notes">Lets look at an example.
</aside></section><section><p>Imagine you work on a feature and your class gets bigger and bigger.
At some point you decide this is no longer understandable and you split
the class into multiple classes with one class (Main) that handles the others.</p><p><b>Test do not change for refactor</b></p><blockquote>As the other classes are just implementation details
they should not be mocked.</blockquote><aside class="notes">You should not even write tests for such implementations.
In case that you want or need to test them, you need to mark them
in some way that they are deleted if needed, as they only reflect a
partial behavior.
</aside></section><section><h3>Don't test implementation details</h3><p>The sub classes don't need tests.
If you want to test them anyways, then mark the tests as
"throw away" or something similar.</p><aside class="notes">Whenever implementation details a^^re tested, then you need to
expect that you need to remove the tests when the code is refactored.
</aside></section><section><h3>What are the benefits of this?</h3><p>Tests only break if you change the behavior of the system
and not if you refactor code</p></section></section><section><section><h2>How should you structure your tests?</h2><ul><li>A test</li><li>A test file</li></ul></section><section><h3>Test structure</h3><ul><li>Given (Arrange)</li><li>When (Act)</li><li>Then (Assert)</li></ul><blockquote>A behavior test tends to only include one assertions (rarely more).
</blockquote></section><style>ol.level, h1.level {
  counter-reset: item -1;
  list-style-type: none;
}

ol.level li:before, h1.level::before {
  content: 'L' counter(item, decimal) ': ';
  counter-increment: item;
}
</style><section><h3>Test file structure</h3><ol class="level"><li>Getting familiar</li><li>Depend on class (DI)</li><li>Depend on class internal</li><li>Test setup dependency</li><li>Multi level describes</li><li>Async tests</li><li>Automate test creation</li></ol></section><section><h3>Getting familiar</h3><pre><code class="language-javascript">describe("L0", ()=>{
  let sut: Component;

  beforeEach(()=> sut = new Component());

  it("should return hello world", ()=>{
    // Given
    // When
    const result = sut.greet();
    // Then
    expect(result).to.equal("hello world");
  })
});</code></pre></section></section><section><h2>Higher level test structures</h2><p>There are two options I know of:</p><ul><li>Contract tests</li><li>Sociable tests</li></ul><aside class="notes">Or you could also call it mindsets.
Just creating tests is fine, but its still possible that in the end
your tests succeed, but in production errors come up.
Following one of these higher level test structures can further
harden your testing.

You don't need to use any of these approaches and they can even be
considered "ugly" by some people
</aside></section><section><section><h2>Contract tests</h2><img class="r-stretch" src="/img/cdc-testing.png" style="background: white"><aside class="notes">Some might know this from the backend to test micro services.

But we often forget that whenever we mock something, then
this also applies to our tests.

At least the left part is usually considered when creating tests

-> img source: https://microsoft.github.io/code-with-engineering-playbook/automated-testing/cdc-testing/
</aside></section><section><h3>Example 1</h3><pre><code class="language-plantuml r-stretch">@startuml
Alice -> Bob: test
Bob --> Alice: Authentication Response
Alice -> Bob: Another authentication Request
Bob --> Alice: Another authentication Response
@enduml
</code></pre></section><section><h3>How to apply contracts testing?</h3><p>When

</p></section><section><h3></h3></section></section><section><section><h1>E2E testing</h1><p>End 2 End testing</p></section><section><h1>What is E2E testing?</h1></section><section><h1>How is it different from unit testing?</h1></section></section><section><section><h1>TDD</h1><p>Test Driven Development</p></section><section><h1>What is TDD?</h1></section></section></div></div><script src="dist/reveal.js"></script><script src="plugin/notes/notes.js"></script><script src="plugin/markdown/markdown.js"></script><script src="plugin/highlight/highlight.js"></script><script>Reveal.initialize( {
  hash: true,
  plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
} );</script></body></html>