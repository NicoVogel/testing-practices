<!DOCTYPE html><html><head><base href="/testing-practices/"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Testing Practices</title><link rel="stylesheet" href="dist/reset.css" type="text/css"><link rel="stylesheet" href="dist/reveal.css" type="text/css"><link rel="stylesheet" href="dist/theme/black.css" type="text/css"><link rel="stylesheet" href="plugin/highlight/monokai.css" type="text/css"></head><body><div class="reveal"><div class="slides"><section><h1>Testing Practices</h1><p>by Nico Vogel</p><aside class="notes">Before we begin, this presentation contains my knowledge of testing
and is by all means no silver bullet.
I just hope to give you a new perspective on some testing topics.
Just take the parts that are relevant for you.

That being said, lets look at the agenda.
</aside></section><section><h1>Agenda</h1><ul><li><a href="#/unit-testing">Unit Testing</a><ul><li><a href="#/what-should-you-actually-test">What should you actually test?</a></li><li><a href="#/how-to-structure-tests">How should you structure your tests?</a></li><li><a href="#/higher-level-test-structures">Higher level test structures</a></li></ul></li><li><a href="#/e2e-testing">E2E Testing</a></li><li><a href="#/tdd">TDD (test driven development)</a></li></ul><blockquote>frontend oriented, but can be applied in backend</blockquote><aside class="notes">This presentation is frontend focused, but the techniques can be applied in backend as well.
The focus point of this presentation is on unit tests</aside></section><section id="unit-testing"><h1>Unit testing</h1><aside class="notes">Unit testing is a skill that takes practice, but is sadly
hardly addressed in university.
</aside></section><section><h2>What is unit testing?</h2><p>A practice to test parts of your code quickly.</p><aside class="notes">Even tough this statement might seem straight forward at first
glance, there are multiple nuances to this skill and I will
outline some of them.
</aside></section><section><section id="what-should-you-actually-test"><h2>What should you actually test?</h2><ul><li>classes?</li><li>functions?</li><li>attributes?</li><li>services?</li><li>components?</li><li>...?</li></ul><aside class="notes">The fist thing to understand is what are we actually testing in unit tests
What do you think, which of these do we test?
As always, the answer is: (next slide)
</aside></section><section><p>What do you actually test?</p><h3>Behavior</h3><p>(Acceptance criteria)</p><aside class="notes">This is a clear must do and it should not be open to debate.
</aside></section><section><img class="r-stretch" src="img/confused-meme.jpg" style="background: white"></section><section data-auto-animate><h3>How to test behavior?</h3></section><section data-auto-animate><h3>How to test behavior?</h3><ol><li>ensure that the system is in the correct state (Given)</li></ol></section><section data-auto-animate><h3>How to test behavior?</h3><ol><li>ensure that the system is in the correct state (Given)</li><li>execute some action (When)</li></ol></section><section data-auto-animate><h3>How to test behavior?</h3><ol><li>ensure that the system is in the correct state (Given)</li><li>execute some action (When)</li><li>expect that the system changed according to the behavior (Then)</li></ol></section><section data-auto-animate><h3>How to test behavior?</h3><ol><li>ensure that the system is in the correct state (Given)</li><li>execute some action (When)</li><li>expect that the system changed according to the behavior (Then)</li></ol><blockquote>Calling a<b> public</b> function or object method</blockquote></section><section><h3>Example -> Router</h3><pre><code class="language-typescript" data-line-numbers="2,8-13|15-22|16-17,22|29-35|40-42|44-51|53-61">// src/router.ts
export class Router {
  private _currentRoute: Route;
  public get currentRoute() {
    return this._currentRoute;
  }

  constructor(private routes: Route[]) {
    if (routes.length === 0) {
      throw new Error("Business Error, Router cannot function without routes.");
    }
    this._currentRoute = this.getDefaultRoute();
  }

  public handleUrlChange(url: string) {
    const route = this.findRoute(this.routes, url)
      ?? this.getDefaultRoute();
    if (route === this._currentRoute) {
      return;
    }
    this._currentRoute = route;
    this.updateShownPage(route);
  }

  private getDefaultRoute(): Route {
    return this.routes[0];
  }

  private findRoute(routes: Route[], url: string): Route | undefined {
    const possibleMatches = this.findMatches(routes, url);
    if (possibleMatches.length === 0) {
      return undefined;
    }
    return this.findBestMatch(possibleMatches);
  }
}

// src/router.spec.ts
describe("Router", () => {
  it("should fail fast, when no routes are provided", () => {
    expect(() => new Router([])).to.throw();
  });

  it("should change route", () => {
    const routes = [{ path: "/user" }, { path: "/profile" }];
    const router = new Router(routes);

    router.handleUrlChange("/profile");

    expect(router.currentRoute).to.equal({ path: "/profile" });
  });

  it("should not change current route, if it is the same route", () => {
    const routes = [{ path: "/user" }, { path: "/profile" }];
    const router = new Router(routes);
    const currentRoute = router.currentRoute;

    router.handleUrlChange("/user");

    expect(router.currentRoute).to.equal(currentRoute);
  });
});</code></pre><aside class="notes"><ul><li>Imagine a router</li><li>we need to handle url changes -> findRoute + updateShownPage</li><li>concentrate on findRoute for a moment</li><li>could be refactored out -> separation of concerns</li><li>before, quick look at tests</li></ul></aside></section><style>.what-to-test-example-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
}
</style><section><h3>Example -> Split Router</h3><div class="what-to-test-example-container"><h4>Old</h4><h4>New</h4><ul><li>router.ts</li><li>router.spec.ts</li></ul><ul><li>find-route.ts</li><li>find-route.spec.ts</li><li>router.ts</li><li>router.spec.ts</li></ul></div><aside class="notes">While it was all in one file before, now the find-route is extracted as a first step
</aside></section><section><h3>Example -> Split Router</h3><pre><code class="language-typescript" data-line-numbers="2|16|29|55-61|64-68|70-74">// src/router.ts
export class Router {
  private _currentRoute: Route;
  public get currentRoute() {
    return this._currentRoute;
  }

  constructor(private routes: Route[]) {
    if (routes.length === 0) {
      throw new Error("Business Error, Router cannot function without routes.");
    }
    this._currentRoute = this.getDefaultRoute();
  }

  public handleUrlChange(url: string) {
    const route = findRoute(this.routes, url) ?? this.getDefaultRoute();
    if (route === this._currentRoute) {
      return;
    }
    this._currentRoute = route;
    this.updateShownPage(route);
  }

  private getDefaultRoute(): Route {
    return this.routes[0];
  }
}
// src/router.spec.ts
describe("Router", () => {
  it("should fail fast, when no routes are provided", () => {
    expect(() => new Router([])).to.throw();
  });

  it("should change route", () => {
    const routes = [{ path: "/user" }, { path: "/profile" }];
    const router = new Router(routes);

    router.handleUrlChange("/profile");

    expect(router.currentRoute).to.equal({ path: "/profile" });
  });

  it("should not change current route, if it is the same route", () => {
    const routes = [{ path: "/user" }, { path: "/profile" }];
    const router = new Router(routes);
    const currentRoute = router.currentRoute;

    router.handleUrlChange("/user");

    expect(router.currentRoute).to.equal(currentRoute);
  });
});

// find-route.ts
export function findRoute(routes: Route[], url: string): Route | undefined {
  const possibleMatches = findMatches(routes, url);
  if (possibleMatches.length === 0) {
    return undefined;
  }
  return findBestMatch(possibleMatches);
}
// find-route.spec.ts
describe("Find Route", () => {
  it("should find no route if no routes are provided", () => {
    const routes: Route[] = [];
    const result = findRoute(routes, "");
    expect(result).to.be.undefined;
  });

  it("should find no route if the url does not match any route", () => {
    const routes: Route[] = [{ path: "/user" }];
    const result = findRoute(routes, "");
    expect(result).to.be.undefined;
  });
  // ...
});</code></pre><aside class="notes"><ul><li>router implementation did not really change</li><li>only moved find-route code out</li><li>router tests did not change</li></ul></aside></section><section><h3>Example takeaways</h3><ul><li>The tests for router are not affected by the extraction</li><li>The find-route function was not mocked</li><li>Only the interface was tested (only public)</li><li>We were able to test system behavior on a smaller level</li></ul><aside class="notes"><ul><li>You should not split the code infinitely, just so that you can test everything</li><li>Instead keep it to a small understandable context at minimum</li></ul></aside></section><section><h3>Why keep tests in router for find-route?</h3><p>You don't know how the code later will be refactored.
This ensures that the behavior is preserved even if the
underlying code is changed.
</p></section><section><h3>Behavior Tests do not break when refactoring</h3><aside class="notes">As long as you don't change the public interface.
</aside></section><section><h2>A few tips to keep in mind</h2></section><section><h3>Common mistakes to avoid</h3><ul><li>testing every function of a class</li><li>testing every attribute of a class</li><li>making assertions that some internal stuff happens in a class -> test the interface</li></ul></section><section><h3>Don't split to much</h3><p>You should not split your code needlessly, just so that you can test everything.</p><p>Instead, aim for small understandable contexts, like "find-route"</p></section></section><section><section id="how-to-structure-tests"><h2>How should you structure your tests?</h2><ul><li>A test</li><li>A test file</li></ul></section><section><h3>Test structure</h3><pre><code class="language-typescript">it('should do something', () => {
  // Given (Arrange)

  // When (Act)

  // Then (Assert)
})</code></pre><blockquote>A behavior test tends to only include one assertion (rarely more).
</blockquote></section><style>ol.level {
  counter-reset: item -1;
  list-style-type: none;
}

ol.level li:before {
  content: 'L' counter(item, decimal) ': ';
  counter-increment: item;
}
</style><section><h3>Test file structure</h3><ol class="level"><li>Getting familiar</li><li>Depend on class (DI)</li><li>Depend on class internal</li><li>Test setup dependency</li><li>Multi level describes</li><li>Complex Async tests</li><li>Automate test creation</li></ol></section><section data-auto-animate data-auto-animate-id="L0"><h3 class="level" data-id="code-title">L0: Getting familiar</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="">class Component {
  greet() { return "hello world"; }
}

</code></pre></section><section data-auto-animate data-auto-animate-id="L0"><h3 class="level" data-id="code-title">L0: Getting familiar</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="5-9">class Component {
  greet() { return "hello world"; }
}

describe("L0", () => {
  let sut: Component;

  beforeEach(() => sut = new Component());
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L0"><h3 class="level" data-id="code-title">L0: Getting familiar</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="10-13">class Component {
  greet() { return "hello world"; }
}

describe("L0", () => {
  let sut: Component;

  beforeEach(() => sut = new Component());

  it("should return hello world", () => {
    const result = sut.greet();
    expect(result).to.equal("hello world");
  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L0"><h3 class="level" data-id="code-title">L0: Getting familiar</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="10-18">class Component {
  greet() { return "hello world"; }
}

describe("L0", () => {
  let sut: Component;

  beforeEach(() => sut = new Component());

  it("should return hello world", () => {
    // Given

    // When
    const result = sut.greet();

    // Then
    expect(result).to.equal("hello world");
  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L1"><h3 class="level" data-id="code-title">L1: Depend on class (DI)</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="|7,16"><script type="text/template">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

</script></code></pre></section><section data-auto-animate data-auto-animate-id="L1"><h3 class="level" data-id="code-title">L1: Depend on class (DI)</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="21-31|23,26,29"><script type="text/template">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

describe("L1", () => {
  let sut: Component;
  let service: StubbedInstance<Service>;

  beforeEach(() => {
    service = stubInterface<Service>();
    sut = new Component(service);
  });
  afterEach(() => sinon.restore());
});
</script></code></pre></section><section data-auto-animate data-auto-animate-id="L1"><h3 class="level" data-id="code-title">L1: Depend on class (DI)</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="31-40"><script type="text/template">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

describe("L1", () => {
  let sut: Component;
  let service: StubbedInstance<Service>;

  beforeEach(() => {
    service = stubInterface<Service>();
    sut = new Component(service);
  });
  afterEach(() => sinon.restore());

  it("should process empty items", async () => {
    // Given
    service.getItems.resolves([]);

    // When
    const result = await sut.getGroupedItems();

    // Then
    expect(result).to.equal(new Map());
  })
});
</script></code></pre></section><section data-auto-animate data-auto-animate-id="L2"><h3 class="level" data-id="code-title">L2: Depend on class internal</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="|6-7"><script type="text/template">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  private service = new Service();
  // constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

</script></code></pre></section><section data-auto-animate data-auto-animate-id="L2"><h3 class="level" data-id="code-title">L2: Depend on class internal</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="22-35|22,30-31"><script type="text/template">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  private service = new Service();
  // constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

import * as ServiceModule from './service';

describe("L2", () => {
  let sut: Component;
  let service: StubbedInstance<Service>;

  beforeEach(() => {
    service = stubInterface<Service>();
    // Override what the constructor of Service returns
    sinon.stub(ServiceModule, "Service").returns(service);
    sut = new Component(service);
  });
  afterEach(() => sinon.restore());
});
</script></code></pre></section><section data-auto-animate data-auto-animate-id="L2"><h3 class="level" data-id="code-title">L2: Depend on class internal</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="36-45"><script type="text/template">class Service {
  getItems() { return fetch('www.get-items.com'); }
}

class Component {
  private service = new Service();
  // constructor(private service: Service) { }
  getGroupedItems() {
    return this.service.getItems()
      .then(response => response.json())
      .then(items => items.reduce(
        (map, item) => {
          const group = map.get(item.group) ?? [];
          group.push(item);
          map.set(item.group, group);
          return map;
        }, new Map())
      );
  }
}

import * as ServiceModule from './service';

describe("L2", () => {
  let sut: Component;
  let service: StubbedInstance<Service>;

  beforeEach(() => {
    service = stubInterface<Service>();
    // Override what the constructor of Service returns
    sinon.stub(ServiceModule, "Service").returns(service);
    sut = new Component(service);
  });
  afterEach(() => sinon.restore());

  it("should process empty items", () => {
    // Given
    service.getItems.return([]);

    // When
    const result = sut.getGroupedItems();

    // Then
    expect(result).to.equal(new Map());
  })
});
</script></code></pre></section><section data-auto-animate data-auto-animate-id="L2"><h3 class="level" data-id="code-title">L2: Depend on class internal</h3><p>Try to avoid this style as it makes tests needlessly complex</p><p>Use Dependency Injection instead to keep tests clean</p></section><section data-auto-animate data-auto-animate-id="L3"><h3 class="level" data-id="code-title">L3: Test setup dependency</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="|8,12">class Component {}
  public readonly id: number;

  constructor(url: string) {
    const urlWrapper = new URL(url);
    const idParam = urlWrapper.searchParams.get("id");
    if (!idParam) {
      throw new Error('The id parameter is required');
    }
    const parsedId = +idParam;
    if (Object.is(parsedId, NaN)) {
      throw new Error('The id parameter is not a number');
    }
    this.id = parsedId;
  }
}

</code></pre></section><section data-auto-animate data-auto-animate-id="L3"><h3 class="level" data-id="code-title">L3: Test setup dependency</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="18-23">class Component {}
  public readonly id: number;

  constructor(url: string) {
    const urlWrapper = new URL(url);
    const idParam = urlWrapper.searchParams.get("id");
    if (!idParam) {
      throw new Error('The id parameter is required');
    }
    const parsedId = +idParam;
    if (Object.is(parsedId, NaN)) {
      throw new Error('The id parameter is not a number');
    }
    this.id = parsedId;
  }
}

describe("L3", () => {
  let sut: Component;
  const initTest = (url) => {
    sut = new Component(url);
  }
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L3"><h3 class="level" data-id="code-title">L3: Test setup dependency</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="24-33|20-22,26">class Component {}
  public readonly id: number;

  constructor(url: string) {
    const urlWrapper = new URL(url);
    const idParam = urlWrapper.searchParams.get("id");
    if (!idParam) {
      throw new Error('The id parameter is required');
    }
    const parsedId = +idParam;
    if (Object.is(parsedId, NaN)) {
      throw new Error('The id parameter is not a number');
    }
    this.id = parsedId;
  }
}

describe("L3", () => {
  let sut: Component;
  const initTest = (url) => {
    sut = new Component(url);
  }

  it("should parse id successfully", () => {
    // Given
    initTest("http://test.com?id=1");

    // When
    const result = sut.id;

    // Then
    expect(result).to.equal(1);
  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L3"><h3 class="level" data-id="code-title">L3: Test setup dependency</h3><p>Usually needed when you want to test something within the constructor
or for L4/L6
</p></section><section data-auto-animate data-auto-animate-id="L4"><h3 class="level" data-id="code-title">L4: Multi level describes</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="">function hasElement(
  items: (number | string)[],
  value: number | string
): boolean {
  return !!items.find((x) => x === value);
}

</code></pre></section><section data-auto-animate data-auto-animate-id="L4"><h3 class="level" data-id="code-title">L4: Multi level describes</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="8-16">function hasElement(
  items: (number | string)[],
  value: number | string
): boolean {
  return !!items.find((x) => x === value);
}

describe("L4", () => {
  describe("number values", () => {

  });
  describe("string values", () => {

  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L4"><h3 class="level" data-id="code-title">L4: Multi level describes</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="10-19|22-31">function hasElement(
  items: (number | string)[],
  value: number | string
): boolean {
  return !!items.find((x) => x === value);
}

describe("L4", () => {
  describe("number values", () => {
    it("should find value", () => {
      // Given
      const items = [1, 2, "3", "4"];

      // When
      const result = hasElement(items, 1);

      // Then
      expect(result).to.be.true;
    });
  });
  describe("string values", () => {
    it("should find value", () => {
      // Given
      const items = [1, 2, "3", "4"];

      // When
      const result = hasElement(items, "3");

      // Then
      expect(result).to.be.true;
    });
  });
});
</code></pre></section><style>.l4-container {
  display: grid;
  grid-template-columns: 1fr 1fr
}
</style><section data-auto-animate data-auto-animate-id="L4"><h3 class="level" data-id="code-title">L4: Multi level describes</h3><p>What is the order of execution?</p><div class="l4-container"><ul data-id="order"><li>describe</li><ul><li>beforeEach (1)</li><li>before (2)</li><li>it (3)</li></ul></ul></div></section><section data-auto-animate data-auto-animate-id="L4"><h3 class="level" data-id="code-title">L4: Multi level describes</h3><p>What is the order of execution?</p><div class="l4-container"><ul data-id="order"><li>describe</li><ul><li>beforeEach (1)</li><li>before (2)</li><li>it (3)</li></ul></ul><p data-id="order-result">2,1,3</p></div></section><section data-auto-animate data-auto-animate-id="L4"><h3 class="level" data-id="code-title">L4: Multi level describes</h3><div class="l4-container"><ul data-id="order"><li>describe</li><ul><li>beforeEach (1)</li><li>before (2)</li><li>it (3)</li><li>describe</li><ul><li>afterEach (4)</li><li>it (5)</li><li>it (6)</li></ul><li>describe</li><ul><li>beforeEach (7)</li><li>it (8)</li><li>it (9)</li></ul></ul></ul></div></section><section data-auto-animate data-auto-animate-id="L4"><h3 class="level" data-id="code-title">L4: Multi level describes</h3><div class="l4-container"><ul data-id="order"><li>describe</li><ul><li>beforeEach (1)</li><li>before (2)</li><li>it (3)</li><li>describe</li><ul><li>afterEach (4)</li><li>it (5)</li><li>it (6)</li></ul><li>describe</li><ul><li>beforeEach (7)</li><li>it (8)</li><li>it (9)</li></ul></ul></ul><p data-id="order-result">2, <br>(1,3), <br>(1,5,4,6,4), <br>(1,7,8,7,9)</p></div></section><section data-auto-animate data-auto-animate-id="L5"><h3 class="level" data-id="code-title">L5: Complex Async tests</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="">function runLater(cb: () => void) {
  setTimeout(cb, 50);
}

</code></pre></section><section data-auto-animate data-auto-animate-id="L5"><h3 class="level" data-id="code-title">L5: Complex Async tests</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="5-10">function runLater(cb: () => void) {
  setTimeout(cb, 50);
}

describe("L5", () => {
  let clock: sinon.SinonFakeTimers;

  beforeEach(() => clock = sinon.useFakeTimer());
  afterEach(() => sinon.restore());
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L5"><h3 class="level" data-id="code-title">L5: Complex Async tests</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="11-21|19">function runLater(cb: () => void) {
  setTimeout(cb, 50);
}

describe("L5", () => {
  let clock: sinon.SinonFakeTimers;

  beforeEach(() => clock = sinon.useFakeTimer());
  afterEach(() => sinon.restore());

  it('should run callback after 50 ms', () => {
    // Given
    const cb = sinon.stub();

    // When
    runLater(cb);

    // Then
    clock.tick(50);
    expect(cb).to.have.been.called;
  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L6"><h3 class="level" data-id="code-title">L6: Automate test creation</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="">class RouteBuilder {
  private placeholder = "http://place.holder"
  private url: URL;
  constructor(route: string) {
    this.url = new URL(route, this.placeholder);
  }
}
</code></pre></section><section data-auto-animate data-auto-animate-id="L6"><h3 class="level" data-id="code-title">L6: Automate test creation</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="8-18">class RouteBuilder {
  private placeholder = "http://place.holder"
  private url: URL;
  constructor(route: string) {
    this.url = new URL(route, this.placeholder);
  }

  public appendPath(path: string) {
    this.url.pathname += path;
  }

  public appendQueryParameter(name: string, value: string) {
    this.url.searchParams.set(name, value);
  }

  public toRoute() {
    return this.url.toString().replace(this.placeholder, "");
  }
}
</code></pre></section><section data-auto-animate data-auto-animate-id="L6"><h3 class="level" data-id="code-title">L6: Automate test creation</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="32-39|21-30|41-49|50-57|61-74">class RouteBuilder {
  private placeholder = "http://place.holder"
  private url: URL;
  constructor(route: string) {
    this.url = new URL(route, this.placeholder);
  }

  public appendPath(path: string) {
    this.url.pathname += path;
  }

  public appendQueryParameter(name: string, value: string) {
    this.url.searchParams.set(name, value);
  }

  public toRoute() {
    return this.url.toString().replace(this.placeholder, "");
  }
}

type Appends =
  | {
    type: "path";
    value: string;
    }
  | {
    type: "query";
    name: string;
    value: string;
    };

type TestStructure = {
  name: string;
  data: {
    startValue: string;
    appends: Appends[];
    expectedResult: string;
  };
};

const tests: TestStructure[] = [
  {
    name: "should be the same as input",
    data: {
      startValue: "/test",
      appends: [],
      expectedResult: "/test",
    },
  },
  {
    name: "should append the path",
    data: {
      startValue: "/test",
      appends: [{ type: "path", value: "/sub" }],
      expectedResult: "/test/sub",
    },
  },
  //...
];

describe("L6", () => {
  tests.forEach(({ name, data }) => {
    it(name, () => {
      // Given
      const sut = new RouteBuilder(data.startValue);

      // When
      const result = sut.toRoute();

      // Then
      expect(result).to.equal(data.expectedResult);
    });
  });
});
</code></pre></section><section data-auto-animate data-auto-animate-id="L6"><h3 class="level" data-id="code-title">L6: Automate test creation</h3><pre data-id="code-animation"><code class="language-typescript" data-line-numbers="66-73">class RouteBuilder {
  private placeholder = "http://place.holder"
  private url: URL;
  constructor(route: string) {
    this.url = new URL(route, this.placeholder);
  }

  public appendPath(path: string) {
    this.url.pathname += path;
  }

  public appendQueryParameter(name: string, value: string) {
    this.url.searchParams.set(name, value);
  }

  public toRoute() {
    return this.url.toString().replace(this.placeholder, "");
  }
}

type Appends =
  | {
    type: "path";
    value: string;
    }
  | {
    type: "query";
    name: string;
    value: string;
    };

type TestStructure = {
  name: string;
  data: {
    startValue: string;
    appends: Appends[];
    expectedResult: string;
  };
};

const tests: TestStructure[] = [
  {
    name: "should be the same as input",
    data: {
      startValue: "/test",
      appends: [],
      expectedResult: "/test",
    },
  },
  {
    name: "should append the path",
    data: {
      startValue: "/test",
      appends: [{ type: "path", value: "/sub" }],
      expectedResult: "/test/sub",
    },
  },
  //...
];

describe("L6", () => {
  tests.forEach(({ name, data }) => {
    it(name, () => {
      // Given
      const sut = new RouteBuilder(data.startValue);
      data.appends.forEach((append) => {
        switch (append.type) {
          case "path":
            return sut.appendPath(append.value);
          case "query":
            return sut.appendQueryParameter(append.name, append.type);
        }
      });

      // When
      const result = sut.toRoute();

      // Then
      expect(result).to.equal(data.expectedResult);
    });
  });
});</code></pre></section></section><section><section><h2>Problem with Mocks</h2><img src="img/solitary-test-have-gaps.jpg"><aside class="notes">We often test components in isolation by mocking other components out,
but there is a potential for gaps in the implementation
To address this issue, there are two patterns that help to mitigate the issue
</aside></section><section><h2>Problem with Mocks</h2><img src="img/integration-tests-are-duplicative-and-slow.jpg"><aside class="notes">To fix that we create integration tests that are slow and difficult to maintain as well as duplicate effort.
</aside></section></section><section id="higher-level-test-structures"><h2>Higher level test structures</h2><p>There are two options I know of:</p><ul><li>Contract tests</li><li>Sociable tests</li></ul><aside class="notes">Or you could also call it mindsets.
Just creating tests is fine, but its still possible that in the end
your tests succeed, but in production errors come up.
Following one of these higher level test structures can further
harden your testing.

I have only used the "Contract tests" up until now and only recently learned
of "Sociable tests" and am really interested in the idea.

You don't need to use any of these approaches and they can even be
considered "ugly" by some people
</aside></section><section><section><h2>Contract tests</h2><img class="r-stretch" src="img/cdc-testing.jpg" style="background: white"><aside class="notes">Some might know this from the backend to test micro services.

But we often forget that whenever we mock something, then
this also applies to our tests.

At least the left part is usually considered when creating tests

-> img source: https://microsoft.github.io/code-with-engineering-playbook/automated-testing/cdc-testing/
</aside></section><section><h2>Contract tests</h2><img class="r-stretch" src="img/contract-tests.jpg" style="background: white"><aside class="notes">The tests for the service need to verify the contract.
Otherwise the gap between the implementation is not filled and there is possible misalignment
</aside></section><section><h2>Contract tests</h2><p>Its a reminder to create a test for the service with the same input you expected.</p><aside class="notes">This is easily forgotten that the counter part is also needed.
Also this does result in duplication, but that is not avoidable when using mocks</aside></section></section><section><section><h2>Social tests</h2><img src="img/overlapping-socialble-tests.jpg"><p>Part of checking if A works as it should be is to test that A calls B correctly -> <strong>no mock</strong></p><p>This mitigates the need for integration tests</p><aside class="notes">Source: https://www.youtube.com/watch?v=jwbKSiqG0DI
</aside></section><section><h3>Problem with actually calling everything</h3><p>Eventually you will hit infrastructure you don't want to run in unit tests</p><p>solution -> <strong>Nullable Infrastructure</strong></p></section><section><h3>Nullable Infrastructure</h3><ul><li>Real production code that can be disabled</li><li>Identical semantics -> same code</li><li>Tracks state when needed</li><li>Implemented with embedded stubs</li></ul><aside class="notes">You inject your infrastructure into the constructor and provide two ways factory functions to create the object.
</aside></section><section data-auto-animate><h3>Nullable Infrastructure</h3><p>This means writing test code which is within your production code</p></section><section data-auto-animate><h3>Nullable Infrastructure</h3><p>This means writing test code which is within your production code</p><img src="img/controversial-meme.jpg"><aside class="notes">- we have test code in prod code
+ we no longer need Mocks
+ we only have to do it once, while mocks need to be configured multiple times
+ you don't need integration tests
There is no silver bullet and its a choice to be made
</aside></section><section><h3>Social tests - Sources</h3><ul><li><a href="http://www.jamesshore.com/v2/blog/2018/testing-without-mocks">Blog: Testing without mocks</a></li><li><a href="https://www.youtube.com/watch?v=jwbKSiqG0DI">YouTube: Testing without mocks</a></li><li><a href="https://www.youtube.com/watch?v=3CBamvF9A3Q">YouTube: Microservices Without Mocks Part 1 - The Serve</a></li><li><a href="https://github.dev/jamesshore/livestream/blob/2020-05-26-end/src/infrastructure/command_line.js#L1">Code: Example for Nullable Infrastructure</a></li></ul><aside class="notes">As said, I have not yet worked with it, so please check it out yourself</aside></section></section><style>.higher-structure-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
}
.higher-structure-container ul {
  list-style-type: none;
}
.higher-structure-container li:not(:last-child) {
  margin-bottom: 1.5rem
}
</style><section><h2>Higher level test structures</h2><div class="higher-structure-container"><h4>Contract tests</h4><h4>Sociable tests</h4><ul><li>‚úÖ little extension to what we already know</li><li>‚ùå requires duplicate code</li><li>‚ùå integration tests are needed</li></ul><ul><li>‚ùå is a bit disruptive</li><li>‚úÖ No mocks needed</li><li>‚úÖ No integration tests needed</li></ul></div><aside class="notes">Writing nullable infrastructure tends to be less effort then maintaining mocks.
They only need to be written once.</aside></section><section><section id="e2e-testing"><h1>E2E testing</h1></section><section><h2>What is the difference to Unit Tests?</h2><p>We actually run infrastructure and they are therefore slow</p></section><section><h2>Some considerations for E2E tests</h2><ul><li>Language agnostic</li><li>use <strong>data-test</strong> attributes</li><li>use page objects</li></ul><aside class="notes">Tests should not break, just because you make a spelling correction
or switch the language.
Using data-test or any other data-* attribute decouples your
test from the actual implementation.
Using a page object makes your tests more readable
</aside></section><section data-auto-animate><h2>Page objects</h2><p>Good old OOP</p><pre><code class="language-typescript">export class ProfilePO {
  open() {
    this.menu.clickOnProfile();
    cy.get('[data-test="profile.name"]').should('be.visible');
  }
  changePassword(password: string){/** ... */}
  // ...
}
</code></pre></section><section data-auto-animate><h2>Page objects</h2><p>JS way</p><pre><code class="language-typescript">export const profilePo = {
  open(){
    menu.clickOnProfile();
    cy.get('[data-test="profile.name"]').should('be.visible');
  }
  changePassword(password: string){/** ... */}
  // ...
}
</code></pre></section><section data-auto-animate><h2>Page objects</h2><p>Actions should reflect user behavior</p><p>Actions should contain validations as well</p></section><section><h2>E2E test infrastructure</h2><p>Strive for independent infrastructure that is started just for the E2E tests</p><aside class="notes">This will save you many headaches when it comes to conflicts between running processes</aside></section></section><section><section id="tdd"><h1>Test Driven Development</h1></section><section><h2>What is TDD?</h2><p>Write tests first and then implement it</p><p>Red - Green - Refactor</p><aside class="notes">If you ever heard about TDD, then you most probably have heard these statements.
The general idea of TDD is great, as that you always have confidence and
that you test your tests.

But how do you get started with TDD?
</aside></section><section><h2>Process of TDD</h2><ol><li>Come up with a scenario that you want to test</li><li>Write a suitable test for it (Red)</li><li>Implement it (Green)</li><li>make your code look nice (Refactor)</li></ol><aside class="notes">While this sounds rather simple at first, I noticed that it was rather difficult
to get started.
</aside></section><section data-auto-animate><p>How to get started with TDD?</p><h2>(easy) Bugs</h2></section><section data-auto-animate><p>How to get started with TDD?</p><h2>(easy) Bugs</h2><p>The context is clear:</p><ul><li>the inputs are known (Given)</li><li>the action is clear (When)</li><li>the expected output is known (Then)</li></ul></section><section data-auto-animate><h2 data-id="title">What should be tested with TDD?</h2></section><section data-auto-animate><h2 data-id="title">What should be tested with TDD?</h2><h1 data-id="solution">Behavior</h1></section><section data-auto-animate><img src="img/unexpected-meme.jpg"></section><section><h2>Big benefits of TDD</h2><ul><li>You test your tests</li><li>You end up with a cleaner implementation</li></ul></section><section><h3>Cleaner implementation?</h3><p>Because you start with the test, you automatically make the interface
cleaner and simpler to test.
</p></section><section><h2>You want to know more?</h2><p>There are a lot of good talks out there that go in depth, so here some recommendations</p><ul><li><a href="https://www.youtube.com/watch?v=vOO3hulIcsY" target="_blank">TDD Revisited - Ian Cooper - NDC London 2021</a></li><li><a href="https://www.youtube.com/watch?v=KyFVA4Spcgg" target="_blank">üöÄ Does TDD Really Lead to Good Design? (Sandro Mancuso)</a></li><li><a href="https://www.youtube.com/watch?v=MU7K_V6rFjM" target="_blank">Test Driven Development in Vue with Cypress by Josh Justice</a></li></ul><p>Refactoring example:<a href="https://www.youtube.com/watch?v=jwJnd9ycs6Q" target="_blank">üöÄ Live Refactoring Towards Solid Code</a></p></section></section><section><h1>Key takeaways</h1><ul><li>Test behavior nothing else</li><li>Don't test everything</li><li>Keep in mind that there are always gaps when using mocks</li><li>Try out TDD, its not that hard with Bugs</li></ul><aside class="notes">By testing behavior you can be sure that your tests don't break when
refactoring code

Never ever test internal stuff, this only links your tests to the implementation
and they will break immediately once you start refactoring.

If you want to be sure, then you need another test for every test that uses mocks</aside></section></div></div><script src="dist/reveal.js"></script><script src="plugin/notes/notes.js"></script><script src="plugin/markdown/markdown.js"></script><script src="plugin/highlight/highlight.js"></script><script>Reveal.initialize( {
  hash: true,
  plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
} );</script></body></html>