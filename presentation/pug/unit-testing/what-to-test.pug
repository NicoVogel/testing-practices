section
  section(id="what-should-you-actually-test")
    h2 What should you actually test?
    ul
      li classes?
      li functions?
      li attributes?
      li services?
      li components?
      li ...?
    aside(class='notes').
      The fist thing to understand is what are we actually testing in unit tests
      What do you think, which of these do we test?
      As always, the answer is: (next slide)

  section
    p What do you actually test?
    h3 Behavior
    p (Acceptance criteria)
    aside(class='notes').
      This is a clear must do and it should not be open to debate.

  section
    img(class='r-stretch' src='img/confused-meme.jpg' style='background: white')

  - var howToTest_header = 'How to test behavior?';
  - var howToTest_1 = 'ensure that the system is in the correct state (Given)';
  - var howToTest_2 = 'execute some action (When)';
  - var howToTest_3 = 'expect that the system changed according to the behavior (Then)';

  section(data-auto-animate)
    h3=howToTest_header

  section(data-auto-animate)
    h3=howToTest_header
    ol
      li=howToTest_1

  section(data-auto-animate)
    h3=howToTest_header
    ol
      li=howToTest_1
      li=howToTest_2

  section(data-auto-animate)
    h3=howToTest_header
    ol
      li=howToTest_1
      li=howToTest_2
      li=howToTest_3

  section(data-auto-animate)
    h3=howToTest_header
    ol
      li=howToTest_1
      li=howToTest_2
      li=howToTest_3
    blockquote
      | Calling a
      b  public
      |  function or object method

  section
    h3 Example -> Router
    pre
      code(class="language-typescript" data-line-numbers="2,5-11|14-22").
        // src/router.ts
        export class Router {
          private currentRoute: Route;

          constructor(private routes: Route[]) {
            if (routes.length === 0) {
              throw new Error(
                'Business Error, Router cannot function without routes.'
              );
            }
            this.currentRoute = this.getDefaultRoute();
          }

          public handleUrlChange(url: URL) {
            const route = this.findRoute(this.routes, url)
              ?? this.getDefaultRoute();
            if (route === this.currentRoute) {
              return;
            }
            this.currentRoute = route;
            this.updateShownPage(route);
          }

          private getDefaultRoute(): Route {
            return this.routes[0];
          }

          private findRoute(routes: Route[], url: URL): Route | undefined {
            const possibleMatches = this.findMatches(routes, url);
            if (possibleMatches.length === 0) {
              return undefined;
            }
            return this.findBestMatch(possibleMatches);
          }
        }



  section
    p.
      Imagine you work on a feature and your class gets bigger and bigger.
      At some point you decide this is no longer understandable and you split
      the class into multiple classes with one class (Main) that handles the others.
    p
      b Behavior Tests do not break when refactoring
    blockquote.
      As the other classes are just implementation detail
      they should not be mocked.
    aside(class='notes').
      You should not even write tests for such implementations.
      In case that you want or need to test them, you need to mark them
      in some way that they are deleted if needed, as they only reflect a
      partial behavior.

  section
    h3 Don't test implementation details
    p.
      The sub classes don't need tests.
      If you want to test them anyways, then mark the tests as
      "throw away" or something similar.
    aside(class='notes').
      Whenever implementation details a^^re tested, then you need to
      expect that you need to remove the tests when the code is refactored.

  section
    h3 Common mistakes to avoid
    ul
      li testing every function of a class
      li testing every attribute of a class
      li making assertions that some internal stuff happens in a class

  section
    h3 What are the benefits of this?
    p.
      Tests only break if you change the behavior of the system
      and not if you refactor code
